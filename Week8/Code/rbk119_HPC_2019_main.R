#Author: Ruth Keane (ruth.keane19@imperial.ac.uk)
#Script: rbk119_HPC_2019_main.R
#Desc: main classwork HPC
#Arguments: none
#Input: none
#Output: none
#Date: Nov 2019

rm(list=ls())
graphics.off()

# CMEE 2019 HPC excercises R code main proforma
# you don't HAVE to use this but it will be very helpful.  If you opt to write everything yourself from scratch please ensure you use EXACTLY the same function and parameter names and beware that you may loose marks if it doesn't work properly because of not using the proforma.

name <- "Ruth Keane"
preferred_name <- "Ruth"
email <- "ruth.keane19@imperial.ac.uk"
username <- "rbk119"
personal_speciation_rate <- 0.004345 
#only for hpc # will be assigned to each person individually in class and should be between 0.002 and 0.007
require(ggplot2)
# Question 1
species_richness <- function(community){
  #calculate number of unique species in the community
  richness<-length(unique(community))
  return(richness)
}

# Question 2
init_community_max <- function(size){
   #make a vector from one to the size of the community
  imax<-as.vector(seq(1,size,1))
  return(imax)
}

# Question 3
init_community_min <- function(size){
  #make a vector of ones the size of the community
  imin<-rep(1,length=size)
  return(imin)
}

# Question 4
choose_two <- function(max_value){
  #make a vector with values between 1 and max value
  imax<-as.vector(seq(1,max_value,1))
  #randomly sample two from this vector
  two<-as.vector(sample(imax,2,replace=FALSE))
  return(two)
}

# Question 5
neutral_step <- function(community){
  #get two random values from the length of community
  indexes<-choose_two(length(community))
  #remove one of these indexes in community
  community2<-community[-indexes[1]]
  #replace this with the second index of community
  community2<-c((community[indexes[2]]),community2)
  return(community2)
}


# Question 6
neutral_generation <- function(community){
  #sample 1 or 2
  a<-sample(1:2,1)
  #number of generations
  generations<-length(community)/2 
  #half the time round down generations
  if(a==1){
    generations<-floor(generations)
  }else{
  #half the time round up generations
    generations<-ceiling(generations)
  }
  for (i in 1:generations){
    #do neutral step generations number of time
    community<-neutral_step(community)
  }
 return(community)
}

# Question 7
neutral_time_series <- function(community,duration)  {
  #richness is an empty vector with length duration
  richness<-vector(length=duration)
  for(j in (1:duration)){
    #neutral generations for duration number of times
    community<-neutral_generation(community)
    #species richness at each timepoint
    richness[j]<-species_richness(community)
  }
  return(richness)
}

# Question 8
question_8 <- function() {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  plot(neutral_time_series(init_community_max(100),duration=200),xlab="Generation",ylab="Species Richness")
  return("Species richness of 1 ")
}

# Question 9
neutral_step_speciation <- function(community,speciation_rate)  {
  #choose two indexes for community
  indexes<-choose_two(length(community))
  #remove first index
  community2<-community[-indexes[1]]
  #random number between 0 and 1
  rand<-runif(1,0,1)
  if(rand>speciation_rate){
    #if random number is > speciation rate replace the deleted index with a second index
    community2<-c((community[indexes[2]]),community2) 
  }else{
    # if random number < speciation rate, add a new species by finding the maximum in community and adding 1
    community2<-c(community2,max(community)+1)
  }
  return(community2)
}

# Question 10
neutral_generation_speciation <- function(community,speciation_rate)  {
  a<-sample(1:2,1)
  #find number of generations 
  generations<-length(community)/2 
  if(a==1){
    generations<-floor(generations)
  }else{
    generations<-ceiling(generations)
  }
  for (i in 1:generations){
    #neutral steps generation times
    community<-neutral_step_speciation(community,speciation_rate =speciation_rate)
  }
  return(community)
}

  
# Question 11
neutral_time_series_speciation <- function(community,speciation_rate,duration)  {
  richness<-vector(length=duration)
  for(j in (1:duration)){
    #neutral generations with speciation for each in duration
    community<-neutral_generation_speciation(community=community, speciation_rate = speciation_rate)
    #find richess at this point and add to the vector
    richness[j]<-species_richness(community)
  }
  return(richness)
}

# Question 12
question_12 <- function()  {
  graphics.off()
  #plot(neutral_time_series(init_community_max(100),duration=200),xlab="Generation",ylab="Species Richness")
  mat<-as.data.frame(matrix(ncol=3, nrow=400))
  min<-neutral_time_series_speciation(community=init_community_min(100),speciation_rate = 0.1, duration=200)
  max<-neutral_time_series_speciation(community=init_community_max(100),speciation_rate = 0.1, duration=200)
  time<-seq(1,200,1)

  graphics.off()
  plot(time,min,col="blue",ylab="Species richness")
  points(time,max,col="red")
  #matrix<-matrix(c(a,b),nrow=200)
#  require(ggplot2)
  #  ggplot(aes(mat[,1],mat[,2],colour=which), data=mat)+geom_point()+xlab("Generation")+ylab("Species Richness")
  return("They converge to similar species richnesses. The neutral model gives these results because new species are being added and the when there are many species, there is a higher chance of a population going extinct")
}


# Question 13
species_abundance <- function(community)  {
  
  community_table<-table(community)
  community_table<-sort(community_table,decreasing = TRUE)
  abundancevec<-vector()
  index=0
  for (i in community_table){
    index=index+1
    abundancevec[index]<-i
  }
   return(abundancevec)
  }

# Question 14
octaves <- function(abundance_vector) {
  #to find n
  m<-max(abundance_vector)
  number_of_octaves<-log(m)/log(2)
  number_of_octaves<-ceiling(number_of_octaves)
  abundance_table<-tabulate(abundance_vector)
  octave_vector<-vector(length=number_of_octaves)
  for (n in (1:number_of_octaves)){
    a<-2^(n-1)
    b<-(2^n)-1
    octave_vector[n]<-sum(abundance_table[a:b],na.rm = TRUE)
  }
  return(octave_vector)
  }
  
# Question 15
sum_vect <- function(x, y) {
  len_x<-length(x)
  len_y<-length(y)
  if (len_x>len_y){
    y_new<-rep(0,len_x)
    y_new[1:len_y]<-y
    y<-y_new
    }else{
      x_new<-rep(0,len_y)
      x_new[1:len_x]<-x
      x<-x_new
    }
  sum<-x+y
  return(sum)
}

# Question 16 
question_16 <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  octaves_matrix<-matrix(nrow=200,ncol=10)
  community_max<-init_community_max(100)
  for (p in 1:200){
  community_max<-neutral_generation_speciation(community=community_max,speciation_rate = 0.1)
  }
  abundance<-species_abundance(community_max)
  octaves_matrix<-octaves(abundance)
  o<-1
  #oc[1,1:length(octaves(abundance))]<-octaves(abundance)
  
  #dont need to do both
  gens<-seq(20,2000,20)
  nint<-1:19
  
  for (d in gens){
    for (q in nint){
      community_max<-neutral_generation_speciation(community=community_max,speciation_rate = 0.1)}
    community_max<-neutral_generation_speciation(community=community_max,speciation_rate = 0.1)
    abundance<-species_abundance(community_max)
    o<-o+1
    #octaves_matrix[o,1:length(octaves(abundance))]<-octaves(abundance)
    octaves_matrix<-sum_vect(octaves_matrix,octaves(abundance))
  }
  octaves_matrix<-octaves_matrix/o
  barplot(octaves_matrix)
  #return(oc)
  return("The initial community size is not important as the bar chart is the same shape for both init_community_min and init_community_max")
}

# Question 17
cluster_run <- function(speciation_rate, size, wall_time, interval_rich, interval_oct, burn_in_generations, output_file_name)  {
  community<-init_community_min(size=size)
  a<-proc.time()
  b<-proc.time()-a
  nruns=0
  richrows=0
  richness<-c()
  oct<-list()
  while (((b[3])/60)<wall_time){
    community=neutral_generation_speciation(community=community,speciation_rate =speciation_rate )
    nruns=nruns+1
    b<-proc.time()-a
    if (nruns<burn_in_generations){
      if (nruns%%interval_rich==0){
        richness<-c(richness,species_richness(community))
      }
    }
    #oct<-list()
    if (nruns%%interval_oct==1){
      octrows=length(oct)+1
      oct[[octrows]]<-(octaves(species_abundance(community)))
      print(b)
    }
  }
  c<-proc.time()-a
  c<-c[3]
  filename<-paste0(output_file_name,".rda")
  save(oct,community,speciation_rate,richness,wall_time,interval_rich,interval_oct,burn_in_generations,size,c,file=filename)
}
# Questions 18 and 19 involve writing code elsewhere to run your simulations on the cluster

# Question 20 
process_cluster_results <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
    octaves_list<-list(vect500=c(0),vect1000=c(0),vect2500=c(0),vect5000=c(0))
   count<-list(vect500=0,vect1000=0,vect2500=0,vect5000=0)
  for (i in 1:100){
    file<-paste0("output2_",i,".rda")
    load(file)
    v<-paste0("vect",size)
    which<-(burn_in_generations/interval_oct)+1
    for (j in (which:length(oct))){
      octaves_list[[v]]<-sum_vect(octaves_list[[v]],oct[[j]])
      count[[v]]<-count[[v]]+1
    }
  }
  combined_results<-list(0,0,0,0)
  for (k in (1:length(octaves_list))){
        combined_results[[k]]<-octaves_list[[k]]/count[[k]]
      } 
  par(mfrow=c(2,2))
  #sizes<-list(graph500=500,graph1000=1000,graph2500=2500,graph5000=5000)
     barplot(combined_results[[1]],main="Size=500",xlab="Species Abundance Octave",ylab="Mean frequency") 
     barplot(combined_results[[2]],main="Size=1000",xlab="Species Abundance Octave",ylab="Mean frequency")
     barplot(combined_results[[3]],main="Size=2500",xlab="Species Abundance Octave",ylab="Mean frequency")
     barplot(combined_results[[4]],main="Size=5000",xlab="Species Abundance Octave",ylab="Mean frequency")
 #for (m in 1:4){
#   data<-as.data.frame((combined_results[[m]]))     
#data[2]<-seq(1,nrow(data),1)
  # }
   ## ggplot(data=data,aes(V2,(combined_results[[m]])))+geom_bar(stat="identity")+theme_bw()+ylim(0,20)
 #  do.call(grid.arrange,p)
  # ggarrange(p[[1]])
   #p<-list()  #   grid.arrange(p1, p2, nrow = 1)
     save(combined_results,file="rbk119_cluster_results.rda")
  return(combined_results)
}

# Question 21
question_21 <- function()  {
 dimensions<-log(8)/log(3)
 ans<-list(dimensions,"when the width is multiplied by 3, the pattern repeats 8 times. 3^x=8. So x=log8/log3")
   return(ans)
}

# Question 22
question_22 <- function()  {
  dimensions<-log(20)/log(3)
  ans<-list(dimensions,"when the width is multiplied by three, the area is multiplied by 20. 3^x=20, so x=log20/log3")
  return(ans)
}

# Question 23
chaos_game <- function()  {
  graphics.off()
  # clear any existing graphs and plot your graph within the R window
    # coordinates
  #x<-c(0,3,4)
  #y<-c(0,4,1)
  x<-c(0,0)
  A<-c(0,0)
  B<-c(3,4)
  C<-c(4,1)
  options<-list(A,B,C)
  plot(x[1],x[2],cex=0.0001,xlim=c(0,5),ylim=c(0,5))
  for (i in 1:50000){
  points(x[1],x[2],cex=0.0001,col="dark green")
  s<-sample(options,1)
  s<-(s[[1]])
  x<-(x+s)/2
  }
  return("A fractal is made on the graph. increasing the repetitions makes this more well defined. However at higher numbers of points some definition is lost")
}

# Question 24
turtle <- function(start_position, direction, length,colour)  {
  adjacent<-cos(direction)*length
  opposite<-sin(direction)*length
  movement<-c(adjacent,opposite)
  end<-start_position+movement
  segments(start_position[1],start_position[2],end[1],end[2],col=colour)
  return(end) # you should return your endpoint here.
}

# Question 25
elbow <- function(start_position, direction, length)  {
 end<-turtle(start_position,direction,length,"blue") 
 turtle(start_position=end,direction=direction-pi/4,length=0.95*length,"blue")
}

# Question 26
spiral <- function(start_position, direction, length)  {
  start_position<-turtle(start_position,direction,length,"green") 
  if (length>0.01){
  start_position<-spiral(start_position=start_position,direction=direction-pi/4,length=length*0.95)
  }
  return("calling a function from a function in this way produces and infinite loop, causing an error message")
}
  
# Question 27
draw_spiral <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  plot(-5:5,-5:5,"n")
  spi<-spiral(start_position = c(-2,1),direction<-pi/4,length=2)
  return(spi)
}

# Question 28
tree <- function(start_position, direction, length)  {
  start_position<-turtle(start_position,direction,length,"green") 
  if (length>0.01){
    tree(start_position=start_position,direction=direction-pi/4,length=length*0.65)
    tree(start_position=start_position,direction=direction+pi/4,length=length*0.65)
  }
}
draw_tree <- function()  {
   # clear any existing graphs and plot your graph within the R window
  graphics.off()
  plot(c(-2,2),c(-1,3),xlab=" ", ylab=" ","n")
  tree(start_position = c(0,0), direction=pi/2, length=1)
}

# Question 29
fern <- function(start_position, direction, length)  {
  start_position<-turtle(start_position,direction,length,"red") 
  if (length>0.01){
    fern(start_position=start_position,direction=direction-pi/4,length=length*0.38)
    fern(start_position=start_position,direction=direction,length=length*0.87)
  }
}
draw_fern <- function()  {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  plot(c(-2,2),c(-1,3),xlab=" ", ylab=" ","n")
  fern(start_position = c(0,0), direction=pi/2, length=1)
  }

# Question 30
fern2 <- function(start_position, direction, length,dir)  {
  start_position<-turtle(start_position,direction,length,"purple") 
  if (length>0.01){
    #dir=-1*dir
    fern2(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.38,dir=dir)
    fern2(start_position=start_position,direction=direction,length=length*0.87,dir=-dir)
  #  if (dir==1){
  #   fern2(start_position=start_position,direction=direction+pi/4,length=length*0.38,dir=1)
  #   fern2(start_position=start_position,direction=direction,length=length*0.87,dir=1)
  # }
    }
}
draw_fern2 <- function()  {
  # clear any exist ing graphs and plot your graph within the R window
  graphics.off()
  plot(c(-2,2),c(0,8),xlab=" ", ylab=" ","n")
  fern2(start_position = c(0,0), direction=pi/2, length=1,dir=1)
}

# Challenge questions - these are optional, substantially harder, and a maximum of 16% is available for doing them.  
calc<-function(gen,community){
  # graphics.off()
  n<-length(community)
  richness<-matrix(ncol=gen,nrow=n)
  
  for (i in 1:n){
    richness[i,]<-neutral_time_series_speciation(community=community,speciation_rate = 0.1,duration =gen)
  } 
  matrix<-matrix(nrow=4,ncol=gen)
  time<-1:gen
  matrix[1,]<-time
  for (k in 1:gen){
    mean<-mean(richness[,k])
    stddev<-sd(richness[,k])
    error <- qnorm(0.986)*stddev/sqrt(n)
    lower<-mean-error
    higher<-mean+error
    matrix[2,k]<-mean
    matrix[3,k]<-lower
    matrix[4,k]<-higher
  }
  matrix<-as.data.frame(t(matrix))
  colnames(matrix)<-c("time","mean","low","high")
  
  
  return(matrix)
}
# Challenge question A
Challenge_A <- function() {
  # clear any existing graphs and plot your graph within the R window
 # graphics.off()
  #rm(list=ls()) 

#  +geom_errorbar(aes(ymin=richnessmin[101,], ymax=richnessmin[102,]), width=.1)


  plotcommunity<-function(community){
  graphics.off()
  matrix<-calc(200,community)
  ggplot(data=matrix,aes(x=time,y=mean), colour="black") +
      geom_point()+theme_bw()+geom_line()+
      geom_errorbar(aes(ymin=low, ymax=high, width=.1),color="blue")+
      geom_vline(xintercept=50,color="red")
  }
  community<-init_community_max(100)
  plotcommunity(community)
  community<-init_community_min(100)
  plotcommunity(community)
  

}
# Challenge question B
Challenge_B <- function() {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  means<-matrix(nrow=10,ncol=200)
  colnames(means)<-1:200
  makecommunitymatrix<-function(communitylength){
    listfact<-vector()
    for (i in (1:communitylength)){
      if (communitylength%%i==0){
        listfact<-c(listfact,i)
      }
    }
    communitymatrix<-matrix(nrow=length(listfact),ncol=communitylength)
   k=1
    for(j in listfact){
     #print(1:j)
       fill<-1:j
      communitymatrix[k,]<-fill
      k=k+1
    }
   return(communitymatrix)
  }

communitymatrix<-makecommunitymatrix(100)
gen<-200
plotting<-function(communitymatrix,gen){
toplot<-as.data.frame(matrix(nrow=nrow(communitymatrix)*gen,ncol=3))
q=0
  for (row in (1:nrow(communitymatrix))){
#while (q<ncol(toplot)){ 
 community<-communitymatrix[row,]
    matrix<-calc(gen,community)
    toplot[(q+1):(gen+q),1]<-matrix[,2]
    toplot[(q+1):(gen+q),3]<-max(community)
    q<-gen+q
    #rownames(means[row])<-row
  }
#toplot[nrow(toplot),]<-1:nrow(toplot)
toplot[,2]<-rep(1:gen,nrow(communitymatrix))
colnames(toplot)<-c("mean","time","initial_species_number")
toplot$initial_species_number<-as.factor(toplot$initial_species_number)
ggplot(data=toplot,aes(x=time,y=mean,colour=initial_species_number))+geom_point()
}
plotting(communitymatrix,gen)
##add lines for best on chLLENGE A

}
# Challenge question C  
Challenge_C <- function() {
  # clear any existing graphs and plot your graph within the R window
  graphics.off()
  richness_matrix<-matrix(ncol=3,nrow =(3999*25+7999*25+19999*25+39999*25))
  r=0
  for (i in 1:100){
    file<-paste0("mean_dataframwput2_",i,".rda")
    load(file)
    richness_matrix[(r+1):(r+length(richness)),1]<-richness
    richness_matrix[(r+1):(r+length(richness)),2]<-1:length(richness)
    richness_matrix[(r+1):(r+length(richness)),3]<-size
    r=r+length(richness)
  }
    richness_matrix=as.data.frame(richness_matrix)
    colnames(richness_matrix)=c("richness","generation","size")
    size_vector<-c(500,1000,2500,5000)
    mean_dataframe<-matrix(ncol=3,nrow=3999+7999+19999+39999)
    p=0
    for (s in 1:4){
       sub<- subset(richness_matrix, size==size_vector[s])
       mean_dataframe[(p+1):(p+(length(unique(sub$generation)))),2]<-tapply(sub$richness, sub$generation,mean)
       mean_dataframe[(p+1):(p+(length(unique(sub$generation)))),1]<-1:(length(unique(sub$generation)))
       mean_dataframe[(p+1):(p+(length(unique(sub$generation)))),3]<-size_vector[s]
       p<-p+(length(unique(sub$generation)))
       }
    
    mean_dataframe=as.data.frame(mean_dataframe)
    colnames(mean_dataframe)=c("generation","mean_species_richness","size")
    mean_dataframe$size<-as.factor(mean_dataframe$size)
    
    graph<-ggplot(data=mean_dataframe,aes(x=generation,y=mean_species_richness,color=size))+theme_bw()+geom_point(size=0.1)
    
return(graph)
  }

# Challenge question D
Challenge_D <- function() {
    
    graphics.off()
    initialising<-function(J,speciation_rate){
    lineages<-rep(1,J)
    abundances<-c()
    N<-J
    theta<-speciation_rate*((J-1)/(1-speciation_rate))
    while(N>1){
    poss<-1:length(lineages)
    j<-sample(x=poss,size=1)
    randnum<-runif(1,0,1)
    if ((randnum)<(theta/(theta+N-1))){
      abundances<-append(abundances,lineages[j])
      }else{
        poss2<-poss[-j]
        i<-sample(x=poss2,size=1)
        lineages[i]<-lineages[i]+lineages[j]
      }
      lineages<-lineages[-j]
      N<-N-1
    }
    abundances<-append(abundances,lineages)
        return(abundances)
    }
      
  octaves_list<-list(vect500=c(0),vect1000=c(0),vect2500=c(0),vect5000=c(0))
  count<-list(vect500=0,vect1000=0,vect2500=0,vect5000=0)
  sizes<-c(500,1000,2500,5000)
  octave_number<-c(942522, 202368, 21226, 1975)
  #octave_number<-c(50, 50, 50, 50)
  
  for (j in 1:4){
    for (k in 1:octave_number[j]){
    abundances<-initialising(J=sizes[j],speciation_rate = personal_speciation_rate)
  oct<-octaves(abundances)
  octaves_list[[j]]<-sum_vect(octaves_list[[j]],oct)
  count[[j]]<-count[[j]]+1
    }
  }
  combined_results<-list(0,0,0,0)
  for (k in (1:length(octaves_list))){
    combined_results[[k]]<-octaves_list[[k]]/count[[k]]
  } 
  par(mfrow=c(2,2))
  #sizes<-list(graph500=500,graph1000=1000,graph2500=2500,graph5000=5000)
  barplot(combined_results[[1]],main="Size=500",xlab="Species Abundance Octave",ylab="Mean frequency") 
  barplot(combined_results[[2]],main="Size=1000",xlab="Species Abundance Octave",ylab="Mean frequency")
  barplot(combined_results[[3]],main="Size=2500",xlab="Species Abundance Octave",ylab="Mean frequency")
  barplot(combined_results[[4]],main="Size=5000",xlab="Species Abundance Octave",ylab="Mean frequency")

    return("1200 CPU hours were used intially. An equivalent number of simulations took 15 seconds using the coalescence method.")
}

# Challenge question E
Challenge_E <- function() {
  graphics.off()
  # clear any existing graphs and plot your graph within the R window
  # coordinates
  #x<-c(0,3,4)
  #y<-c(0,4,1)
  x<-c(0,0)
  #A<-c(0,0)
  #B<-c(3,4)
  #C<-c(4,1)
  A<-c(2,0)
  B<-c(-2,0)
  C<-c(0,sqrt(12))
  options<-list(A,B,C)
  plot(x[1],x[2],cex=0.0001,xlim=c(-2,2),ylim = c(0,4))
  for (i in 1:50){
    
    s<-sample(options,1)
    s<-(s[[1]])
    x<-(x+s)/2    
    points(x[1],x[2],cex=0.5,col="dark green")
  }
    for (i in 1:50000){
      s<-sample(options,1)
      s<-(s[[1]])
      x<-(x+s)/2    
      points(x[1],x[2],cex=0.0001,col="red")
  }
  
  
  return("changing the initial value has no effect on the final shape. changing the colour of the first few values showed that values jumped around the points of the triangle and initial results were different each time")
}

# Challenge question F
Challenge_F <- function() {
  # clear any existing graphs and plot your graph within the R window
  par(mfrow=c(2,2))
  #need better
  fernA <- function(start_position, direction, length)  {
    start_position<-turtle(start_position,direction,length,"orange") 
    if (length>0.01){
      fernA(start_position=start_position,direction=direction-pi/4,length=length*0.38)
      fernA(start_position=start_position,direction=direction,length=length*0.87)
    }
  }
  plot(c(0,2),c(-1,8),xlab=" ", ylab=" ","n")
  fernA(start_position = c(0,0), direction=pi/2, length=1)
  
  fern2B <- function(start_position, direction, length,dir)  {
    start_position<-turtle(start_position,direction,length,"blue") 
    if (length>0.01){
      fern2B(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.38,dir=-1)
      fern2B(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.87,dir==1)
    }
  }
  plot(c(-4,1),c(-1,5),xlab=" ", ylab=" ","n")
  fern2B(start_position = c(0,0), direction=pi/2, length=1,dir=1)
  
  
  fern2C <- function(start_position, direction, length,dir)  {
    start_position<-turtle(start_position,direction,length,"purple") 
    if (length>0.01){
      fern2C(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.38,dir==-1)
      fern2C(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.87,dir==1)
    }
  }
  plot(c(-1,3),c(-1,4),xlab=" ", ylab=" ","n")
  fern2C(start_position = c(0,0), direction=0, length=1,dir=1)
  
  fern2D <- function(start_position, direction, length,dir)  {
    start_position<-turtle(start_position,direction,length,"brown") 
    if (length>0.01){
      fern2D(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.38,dir=1)
      fern2D(start_position=start_position,direction=direction+(dir*(pi/4)),length=length*0.87,dir=-1)
    }
  }
  plot(c(-1,1),c(0,4),xlab=" ", ylab=" ","n")
  fern2D(start_position = c(0,0), direction=pi/2, length=1,dir=1)
  ##first bit, change a and maybe c,
  return("type your written answer here")
}

# Challenge question G should be written in a separate file that has no dependencies on any functions here.

##question: population or sample sd-ssample
#question:functions outside ok? or define twice - no , ok out of thing
#how many initial communities is ok- 9 good
#sample ok for D , buut not continous! ok 
###go over richness , to see if my method worked
##not dir comparable but both or longer better- every octave after burn in
##what does line size threshold mean